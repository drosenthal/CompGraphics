# This .cfg file provides common options used among all glue code
# generated for Jogl on all platforms.

# Raise GLException instead of RuntimeException in glue code
RuntimeExceptionType GLException

# Imports needed by all glue code
Import java.nio.*
Import java.util.*
Import net.java.games.jogl.*
Import net.java.games.jogl.impl.*

# Generate "flattened" NIO variants for routines taking C primitive
# pointers that aren't of type void*
NioMode ALL_POINTERS
FlattenNIOVariants true

# Don't output #defines of GL version identifier strings as constants, 
# because we don't need them java-side. 
Ignore GL_VERSION_.+

# Don't output #defines of GL name strings as constants, because we
# don't need them java-side. 
# Format of name strings is found at:
#    http://oss.sgi.com/projects/ogl-sample/registry/doc/template.txt

Ignore (GL|GLU|GLX|WGL|AGL|CGL)_EXT_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_ARB_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_PGI_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_SGI_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_SGIS_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_SGIX_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_MESA_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_HP_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_ATI_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_NV_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_IBM_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_WIN_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_REND_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_APPLE_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_INTEL_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_INGR_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_SUN_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_SUNX_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_3DFX_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_OML_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_I3D_.+
Ignore (GL|GLU|GLX|WGL|AGL|CGL)_S3_.+
Ignore GL_KTX_buffer_region

# Ignore GL functions that deal with explicit pointer values in such a
# way that we cannot implement the functionality in Java
Ignore glGetBufferPointerv
Ignore glGetBufferPointervARB
Ignore glGetPointerv
Ignore glGetPointervEXT
Ignore glGetTexParameterPointervAPPLE
Ignore glGetVertexAttribPointerv
Ignore glGetVertexAttribPointervARB
Ignore glGetVertexAttribPointervNV
Ignore glTracePointerRangeMESA 

# Manually implement glMapBuffer and glMapBufferARB as the size of the returned buffer
# can only be computed by calling another routine
ManuallyImplement glMapBuffer
ManuallyImplement glMapBufferARB

# Ignore the ATI_map_object_buffer extension for now unless someone
# claims they need it, as it will undoubtedly require a similar
# construct to glMapBuffer/glMapBufferARB
Ignore glMapObjectBufferATI
Ignore glUnmapObjectBufferATI

# Ignore some GL functions that have outgoing void** parameters; we cannot yet deal with them
Ignore glGetVariantPointervEXT

# Some GL functions have multiple void* arguments but require them to
# contain data of the same type; make sure that when bindings are
# expanded those arguments have the same type.
MirrorExpandedBindingArgs glSeparableFilter2D 6 7
MirrorExpandedBindingArgs glSeparableFilter2DEXT 6 7
MirrorExpandedBindingArgs glGetSeparableFilter 3 4
MirrorExpandedBindingArgs glGetSeparableFilterEXT 3 4

# FIXME: these extensions require either a handle to a device context
# or take void** parameters or both. Until we think through the
# semantics of each of these individually we need to disable them.
# WGL_ARB_buffer_region
Ignore wglCreateBufferRegionARB
Ignore wglDeleteBufferRegionARB
Ignore wglSaveBufferRegionARB
Ignore wglRestoreBufferRegionARB
Ignore wglGetSyncValuesOML
Ignore wglGetMscRateOML
Ignore wglSwapBuffersMscOML
Ignore wglSwapLayerBuffersMscOML
Ignore wglWaitForMscOML
Ignore wglWaitForSbcOML
Ignore wglGetDigitalVideoParametersI3D
Ignore wglSetDigitalVideoParametersI3D
Ignore wglGetGammaTableParametersI3D
Ignore wglSetGammaTableParametersI3D
Ignore wglGetGammaTableI3D
Ignore wglSetGammaTableI3D
Ignore wglEnableGenlockI3D
Ignore wglDisableGenlockI3D
Ignore wglIsEnabledGenlockI3D
Ignore wglGenlockSourceI3D
Ignore wglGetGenlockSourceI3D
Ignore wglGenlockSourceEdgeI3D
Ignore wglGetGenlockSourceEdgeI3D
Ignore wglGenlockSampleRateI3D
Ignore wglGetGenlockSampleRateI3D
Ignore wglGenlockSourceDelayI3D
Ignore wglGetGenlockSourceDelayI3D
Ignore wglQueryGenlockMaxSourceDelayI3D
Ignore wglCreateImageBufferI3D
Ignore wglDestroyImageBufferI3D
Ignore wglAssociateImageBufferEventsI3D
Ignore wglReleaseImageBufferEventsI3D

#
# Opaques and other directives for platform-independent routines
#

Opaque boolean GLboolean
ReturnsString glGetString

#
# NIOOnly directives for vertex arrays and other core routines
#
NIOOnly glColorPointer
NIOOnly glEdgeFlagPointer
NIOOnly glFeedbackBuffer
NIOOnly glIndexPointer
NIOOnly glNormalPointer
NIOOnly glSelectBuffer
NIOOnly glTexCoordPointer
NIOOnly glVertexPointer
#
# FIXME: we should probably be ignoring the "EXT" variants of these
#
NIOOnly glColorPointerEXT
NIOOnly glEdgeFlagPointerEXT
NIOOnly glIndexPointerEXT
NIOOnly glNormalPointerEXT
NIOOnly glTexCoordPointerEXT
NIOOnly glVertexPointerEXT
#
# NIOOnly directives for other extensions
#
NIOOnly glBinormalPointerEXT
NIOOnly glGetBufferSubDataARB
# FIXME: should add way to restrict argument to be a direct ByteBuffer
NIOOnly glGetProgramStringARB
NIOOnly glElementPointerATI
NIOOnly glElementPointerNV
NIOOnly glFogCoordPointer
NIOOnly glFogCoordPointerEXT
NIOOnly glMatrixIndexPointerARB
# NIOOnly glNewObjectBufferATI # FIXME: look up semantics of this routine
NIOOnly glPixelDataRangeNV
NIOOnly glSecondaryColorPointer
NIOOnly glSecondaryColorPointerEXT
NIOOnly glTangentPointerEXT
# NIOOnly glUpdateObjectBufferATI # FIXME: look up semantics of this routine
# NIOOnly glVariantPointerEXT # FIXME: look up semantics of this routine
NIOOnly glVertexArrayRangeNV
NIOOnly glVertexAttribPointerARB
NIOOnly glVertexAttribPointerNV
NIOOnly glVertexWeightPointerEXT
NIOOnly glWeightPointerARB
NIOOnly wglFreeMemoryNV
NIOOnly glXFreeMemoryNV

# Capacity of wglAllocateMemoryNV/glXAllocateMemoryNV return value is
# same as value of first argument
ReturnValueCapacity wglAllocateMemoryNV {0}
ReturnValueCapacity glXAllocateMemoryNV {0}

# Pass arguments to ARB_vertex_program, ARB_fragment_program,
# ARB_shader_objects, NV_vertex_program, NV_fragment_program, and
# ARB_vertex_shader as Strings
ArgumentIsString glLoadProgramNV 3
ArgumentIsString glProgramStringARB 3
ArgumentIsString glProgramNamedParameter4fNV 2
ArgumentIsString glProgramNamedParameter4dNV 2
ArgumentIsString glProgramNamedParameter4fvNV 2
ArgumentIsString glProgramNamedParameter4dvNV 2
ArgumentIsString glGetProgramNamedParameterfvNV 2
ArgumentIsString glGetProgramNamedParameterdvNV 2
ArgumentIsString glShaderSourceARB 2
ArgumentIsString glGetUniformLocationARB 1
ArgumentIsString glBindAttribLocationARB 2
ArgumentIsString glGetAttribLocationARB 1

# Javadoc for the GL class
ClassJavadoc GL /**
ClassJavadoc GL  * <P> The basic interface to OpenGL, providing access to core
ClassJavadoc GL  * functionality up through the OpenGL 2.0 specification as well as
ClassJavadoc GL  * all vendor extensions. </P>
ClassJavadoc GL  *
ClassJavadoc GL  * <P> While the APIs for vendor extensions are unconditionally
ClassJavadoc GL  * exposed, the underlying functions may not be present. The method
ClassJavadoc GL  * {@link #isFunctionAvailable} should be used to query the
ClassJavadoc GL  * availability of any non-core function before it is used for the
ClassJavadoc GL  * first time; for example,
ClassJavadoc GL  * <code>gl.isFunctionAvailable("glProgramStringARB")</code>. On
ClassJavadoc GL  * certain platforms (Windows in particular), the most "core"
ClassJavadoc GL  * functionality is only OpenGL 1.1, so in theory any routines first
ClassJavadoc GL  * exposed in OpenGL 1.2, 1.3, and 1.4, 1.5, or 2.0 as well as vendor
ClassJavadoc GL  * extensions should all be queried. Calling an unavailable function
ClassJavadoc GL  * will cause a {@link GLException} to be raised. </P>
ClassJavadoc GL  *
ClassJavadoc GL  * {@link #isExtensionAvailable} may also be used to determine whether
ClassJavadoc GL  * a specific extension is available before calling the routines or
ClassJavadoc GL  * using the functionality it exposes: for example,
ClassJavadoc GL  * <code>gl.isExtensionAvailable("GL_ARB_vertex_program");</code>.
ClassJavadoc GL  * However, in this case it is up to the end user to know which
ClassJavadoc GL  * routines or functionality are associated with which OpenGL
ClassJavadoc GL  * extensions.
ClassJavadoc GL  *
ClassJavadoc GL  * <P> Access to window system-specific extensions is provided through
ClassJavadoc GL  * the {@link WGL} and {@link GLX} interfaces. However, most of these
ClassJavadoc GL  * extensions require access to low-level window system data
ClassJavadoc GL  * structures which are not exposed by this binding, and are therefore
ClassJavadoc GL  * not useful. Calling one particular window system's extension on
ClassJavadoc GL  * another platform will cause a {@link GLException} to be raised
ClassJavadoc GL  * indicating the routine is unimplemented on the current platform.
ClassJavadoc GL  * </P>
ClassJavadoc GL  *
ClassJavadoc GL  * <P> Exceptions to the window system extension naming rules:
ClassJavadoc GL  *
ClassJavadoc GL  * <UL>
ClassJavadoc GL  *
ClassJavadoc GL  * <LI> The NVidia vertex_array_range (VAR) extension, in particular {@link
ClassJavadoc GL  * WGL#wglAllocateMemoryNV} / {@link GLX#glXAllocateMemoryNV} and
ClassJavadoc GL  * associated routines. {@link #glAllocateMemoryNV} has been provided
ClassJavadoc GL  * for window system-independent access to VAR. {@link
ClassJavadoc GL  * #isFunctionAvailable} will translate an argument of
ClassJavadoc GL  * "glAllocateMemoryNV" or "glFreeMemoryNV" into the appropriate
ClassJavadoc GL  * window system-specific name. </P>
ClassJavadoc GL  *
ClassJavadoc GL  * <LI> WGL_ARB_pbuffer, WGL_ARB_pixel_format, and other
ClassJavadoc GL  * platform-specific pbuffer functionality; the availability of
ClassJavadoc GL  * pbuffers can be queried on Windows, X11 and Mac OS X platforms by
ClassJavadoc GL  * querying {@link #isExtensionAvailable} with an argument of
ClassJavadoc GL  * "GL_ARB_pbuffer" or "GL_ARB_pixel_format".
ClassJavadoc GL  *
ClassJavadoc GL  * </UL> <P>
ClassJavadoc GL  *
ClassJavadoc GL  */

# Javadoc for the WGL class
ClassJavadoc WGL /**
ClassJavadoc WGL  * Provides access to the Windows-specific OpenGL vendor extensions.
ClassJavadoc WGL  * See {@link GL} for more information.
ClassJavadoc WGL  */

# Javadoc for the GLX class
ClassJavadoc GLX /**
ClassJavadoc GLX  * Provides access to the X11-specific OpenGL vendor extensions.
ClassJavadoc GLX  * See {@link GL} for more information.
ClassJavadoc GLX  */

# Javadoc for the CGL class
ClassJavadoc CGL /**
ClassJavadoc CGL  * Provides access to the MacOSX-specific OpenGL vendor extensions.
ClassJavadoc CGL  * See {@link GL} for more information.
ClassJavadoc CGL  */

# Javadoc for the XVisualInfo class
ClassJavadoc XVisualInfo /**
ClassJavadoc XVisualInfo  * Wrapper for the XVisualInfo data structure, referenced by some GLX OpenGL
ClassJavadoc XVisualInfo  * extensions. No other access is provided to these data structures so currently
ClassJavadoc XVisualInfo  * this wrapper is not useful to end users, though it is used in the implementation.
ClassJavadoc XVisualInfo  */

# Custom code for querying extensions and exposing
# wglAllocateMemoryNV/glXAllocateMemoryNV
CustomJavaCode GL   /**
CustomJavaCode GL    * Returns true if the specified OpenGL core- or extension-function can be
CustomJavaCode GL    * used successfully through this GL instance given the current host (OpenGL
CustomJavaCode GL    * <i>client</i>) and display (OpenGL <i>server</i>) configuration.<P> 
CustomJavaCode GL    * By "successfully" we mean that the function is both <i>callable</i> 
CustomJavaCode GL    * on the machine running the program and <i>available</i> on the current 
CustomJavaCode GL    * display.<P> 
CustomJavaCode GL    *
CustomJavaCode GL    * In order to call a function successfully, the function must be both
CustomJavaCode GL    * <i>callable</i> on the machine running the program and <i>available</i> on 
CustomJavaCode GL    * the display device that is rendering the output (note: on non-networked, 
CustomJavaCode GL    * single-display machines these two conditions are identical; on networked and/or
CustomJavaCode GL    * multi-display machines this becomes more complicated). These conditions are
CustomJavaCode GL    * met if the function is either part of the core OpenGL version supported by
CustomJavaCode GL    * both the host and display, or it is an OpenGL extension function that both
CustomJavaCode GL    * the host and display support. <P>
CustomJavaCode GL    *
CustomJavaCode GL    * A GL function is <i>callable</i> if it is statically linked, or can be 
CustomJavaCode GL    * dynamically linked at runtime. 
CustomJavaCode GL    * 
CustomJavaCode GL    * Whether or not a GL function is <i>available</i> is determined as follows: 
CustomJavaCode GL    * <ul>
CustomJavaCode GL    *   <li>If the function is an OpenGL core function (i.e., not an
CustomJavaCode GL    *   extension), <code>glGetString(GL_VERSION)</code> is used to determine the
CustomJavaCode GL    *   version number of the highest OpenGL specification version that both host
CustomJavaCode GL    *   and display support, and then the function name is cross-referenced
CustomJavaCode GL    *   with that specification version to see if it is part of that version.

CustomJavaCode GL    *   <li> If the function is an OpenGL extension, the function name is
CustomJavaCode GL    *   cross-referenced with the list returned by
CustomJavaCode GL    *   <code>glGetString(GL_EXTENSIONS)</code> to see if the function is one of
CustomJavaCode GL    *   the extensions that is supported on both host and display.
CustomJavaCode GL    * </ul>
CustomJavaCode GL    *
CustomJavaCode GL    * <b>NOTE:</b>The availability of a function may change at runtime in
CustomJavaCode GL    * response to changes in the display environment. For example, when a window
CustomJavaCode GL    * is dragged from one display to another on a multi-display system, or when
CustomJavaCode GL    * the properties of the display device are modified (e.g., changing the color
CustomJavaCode GL    * depth of the display). Any application that is concerned with handling
CustomJavaCode GL    * these situations correctly should confirm availability after a display
CustomJavaCode GL    * change before calling a questionable OpenGL function. To detect a change in
CustomJavaCode GL    * the display device, please see {@link
CustomJavaCode GL    * GLEventListener#displayChanged(GLDrawable,boolean,boolean)}.
CustomJavaCode GL    *
CustomJavaCode GL    * @param glFunctionName the name of the OpenGL function (e.g., use
CustomJavaCode GL    * "glPolygonOffsetEXT" to check if the {@link
CustomJavaCode GL    * #glPolygonOffsetEXT(float,float)} is available).
CustomJavaCode GL    */
CustomJavaCode GL   public boolean isFunctionAvailable(String glFunctionName);

CustomJavaCode GL   /**
CustomJavaCode GL    * Returns true if the specified OpenGL extension can be
CustomJavaCode GL    * used successfully through this GL instance given the current host (OpenGL
CustomJavaCode GL    * <i>client</i>) and display (OpenGL <i>server</i>) configuration.<P> 
CustomJavaCode GL    *
CustomJavaCode GL    * @param glExtensionName the name of the OpenGL extension (e.g.,
CustomJavaCode GL    * "GL_ARB_vertex_program").
CustomJavaCode GL    */
CustomJavaCode GL   public boolean isExtensionAvailable(String glExtensionName);

CustomJavaCode GL   /**
CustomJavaCode GL    * Provides platform-independent access to the {@link WGL#wglAllocateMemoryNV} /
CustomJavaCode GL    * {@link GLX#glXAllocateMemoryNV} extension.
CustomJavaCode GL    */
CustomJavaCode GL   public java.nio.ByteBuffer glAllocateMemoryNV(int arg0, float arg1, float arg2, float arg3);

CustomJavaCode GL   /** Provides a platform-independent way to specify the minimum swap
CustomJavaCode GL       interval for buffer swaps. An argument of 0 disables
CustomJavaCode GL       sync-to-vertical-refresh completely, while an argument of 1
CustomJavaCode GL       causes the application to wait until the next vertical refresh
CustomJavaCode GL       until swapping buffers. The default, which is platform-specific,
CustomJavaCode GL       is usually either 0 or 1. This function is not guaranteed to
CustomJavaCode GL       have an effect, and in particular only affects heavyweight
CustomJavaCode GL       onscreen components. */
CustomJavaCode GL   public void setSwapInterval(int interval);

#
# Directives needed when processing wglext.h on Windows and other platforms
#
Opaque boolean BOOL
ReturnsString wglGetExtensionsStringARB
ReturnsString wglGetExtensionsStringEXT
Opaque long HANDLE
Opaque long HBITMAP
Opaque long HDC
Opaque long HGDIOBJ
Opaque long HGLRC
Opaque long HPBUFFERARB
Opaque long HPBUFFEREXT
Opaque boolean BOOL
Opaque long PROC
Opaque long void **

#
# Directives needed when processing cglext.h on MacOSX and other platforms
#
Opaque long CGContextRef
Opaque long void **
# Implement the first argument to cglGetProcAddress as String instead
# of byte[]
ArgumentIsString cglGetProcAddress 0

#
# Directives needed when processing glxext.h on X11 and other platforms
#
Opaque long __GLXextFuncPtr
Opaque boolean Bool
Opaque long Display *
Opaque long GLXContext
Opaque long Visual *
# Ignore the empty Display and Visual data structures (though made
# opaque, the references from XVisualInfo and elsewhere are still
# traversed)
Ignore Display
Ignore Visual
# Implement the first argument to glXGetProcAddress as String instead
# of byte[]
ArgumentIsString glXGetProcAddress 0
ArgumentIsString glXGetProcAddressARB 0
ReturnsString glXQueryExtensionsString
ReturnsString glXQueryServerString
ReturnsString glXGetClientString
TemporaryCVariableDeclaration glXChooseFBConfig     int count;
TemporaryCVariableAssignment  glXChooseFBConfig     count = _ptr3[0];
ReturnValueLength             glXChooseFBConfig     count
TemporaryCVariableDeclaration glXChooseFBConfigSGIX int count;
TemporaryCVariableAssignment  glXChooseFBConfigSGIX count = _ptr3[0];
ReturnValueLength             glXChooseFBConfigSGIX count
TemporaryCVariableDeclaration glXGetFBConfigs       int count;
TemporaryCVariableAssignment  glXGetFBConfigs       count = _ptr2[0];
ReturnValueLength             glXGetFBConfigs       count
